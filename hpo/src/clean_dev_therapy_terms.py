"""
GeneX: Developmental / Therapy-Relevant HPO Term Cleaner + Therapy Tagger
=========================================================================
This script refines and categorizes Human Phenotype Ontology (HPO) terms
previously extracted into `dev_therapy_terms.csv`. It filters out anatomical
and non-therapeutic phenotypes and assigns each retained developmental term
to one or more therapy categories (Speech, Physical, Occupational, or
Behavioral/Developmental). The output serves as a curated dataset that maps
HPO terms to clinically actionable therapy domains for use in the GeneX
Knowledge Graph and personalized care recommendations.

INPUT:
    • data_proc/dev_therapy_terms.csv
        - Derived from hp.json using the HPO Developmental Extractor.
        - Contains HPO IDs and labels related to developmental, speech,
          cognitive, and motor domains (raw form).

OUTPUT:
    • data_proc/therapy_relevant_terms_tagged.csv
        - Cleaned and filtered list of HPO terms tagged by therapy relevance.

PROCESS OVERVIEW:

1. **Load Raw Developmental Terms**
    - Reads in `dev_therapy_terms.csv` generated by the ontology extractor.

2. **Define Keyword Logic**
    - `keep_keywords`: Retains only developmental / therapy-relevant
      domains (e.g., “delay”, “speech”, “motor”, “social”).
    - `remove_keywords`: Excludes anatomical, skeletal, or biological
      processes not relevant to therapy (e.g., “ossification”, “bone”,
      “epiphysis”, “teeth”, “puberty”).

3. **Normalize Text**
    - Converts all labels to lowercase (`label_clean`) to ensure robust
      keyword matching.

4. **Filter by Domain Relevance**
    - Keeps only those terms that match any `keep_keywords` and exclude
      any `remove_keywords`.

5. **Assign Therapy Categories**
    - Uses predefined mappings:
        • Speech Therapy → speech, language, articulation, communication
        • Occupational Therapy → fine motor, social, play, coordination
        • Physical Therapy → gross motor, walk, crawl, movement, posture
        • Behavioral / Developmental Therapy → autism, learning, behavior, cognitive
      If a term doesn’t match any specific therapy, it defaults to
      “General Developmental Support”.

6.  **Save Results + Quality Checks**
    - Writes cleaned dataset with therapy categories to the output file.
    - Prints category distribution, sample rows, and missing-value summary.

USAGE CONTEXT:
    This script is part of the GeneX data pipeline for building
    a therapy-aware ontology layer. The resulting CSV supports:
        • Downstream mapping between genetic/developmental conditions
          and recommended therapies.
        • Enrichment of the GeneX dashboard and micro-agent reasoning layer.
        • Statistical summaries of therapy distribution across phenotypes.

Example:
    Input  → “HP:0001263 | Global developmental delay”
    Output → “HP:0001263 | Global developmental delay | General Developmental Support”

    Input  → “HP:0000750 | Delayed speech and language development”
    Output → “HP:0000750 | Delayed speech and language development | Speech Therapy”

"""


import pandas as pd

# === 1. File paths ===
INPUT_PATH = "data_proc/dev_therapy_terms.csv"
OUTPUT_PATH = "data_proc/therapy_relevant_terms_tagged.csv"

print(f"Loading data from {INPUT_PATH} ...")
df = pd.read_csv(INPUT_PATH)

if "label" not in df.columns:
    raise ValueError("Expected a 'label' column in the CSV")

print(f"Loaded {len(df)} rows")

# === 2. Define keyword clusters ===

keep_keywords = [
    "development", "delay", "speech", "language", "motor", "cognitive",
    "learning", "social", "psychomotor", "communication", "autism",
    "interaction", "behavior", "self-feeding", "play"
]

remove_keywords = [
    "ossification", "bone", "epiphysis", "epiphyseal", "carpal", "patellar",
    "fracture", "fontanelle", "cranial", "teeth", "eruption", "puberty",
    "pubic", "menarche", "adrenarche", "thelarche", "meconium",
    "nasolacrimal", "gallbladder", "duct", "hypersensitivity",
    "suture", "skeletal", "ossified", "ossifying", "clavicle",
    "phalanx", "calcaneal", "scaphoid", "trapezium", "trapezoid"
]

therapy_map = {
    "Speech Therapy": [
        "speech", "language", "apraxia", "articulation", "communication"
    ],
    "Occupational Therapy": [
        "fine motor", "social", "self-feeding", "play", "coordination", "grasp"
    ],
    "Physical Therapy": [
        "gross motor", "walk", "sit", "stand", "crawl", "movement", "postural", "mobility"
    ],
    "Behavioral / Developmental Therapy": [
        "autism", "behavior", "learning", "cognitive", "psychomotor", "interaction", "social"
    ],
}

# === 3. Normalize labels ===
df["label_clean"] = df["label"].astype(str).str.lower().str.strip()

# === 4. Filtering logic ===
def is_keep(label):
    if any(word in label for word in remove_keywords):
        return False
    return any(word in label for word in keep_keywords)

df_filtered = df[df["label_clean"].apply(is_keep)]
print(f" Retained {len(df_filtered)} therapy-relevant features ({len(df) - len(df_filtered)} removed).")

# === 5. Assign therapy categories ===
def assign_category(label):
    for therapy, keywords in therapy_map.items():
        if any(word in label for word in keywords):
            return therapy
    return "General Developmental Support"

df_filtered["therapy_category"] = df_filtered["label_clean"].apply(assign_category)

# === 6. Save cleaned + tagged version ===
df_filtered.to_csv(OUTPUT_PATH, index=False)
print(f"Saved cleaned dataset with therapy tags → {OUTPUT_PATH}")

# === 7. Show summary ===
print("\n=== Category distribution ===")
print(df_filtered["therapy_category"].value_counts())

print("\n=== Sample output ===")
print(df_filtered.head(15)[["label", "therapy_category"]])

print("\n=== Missing Values Summary ===")
missing_summary = df_filtered.isna().sum().reset_index()
missing_summary.columns = ["column", "missing_count"]
missing_summary["missing_percent"] = (missing_summary["missing_count"] / len(df_filtered)) * 100
print(missing_summary.to_string(index=False))

print(f"\nFinal shape: {df_filtered.shape[0]} rows × {df_filtered.shape[1]} columns")